#pragma kernel CSMain

#include <UnityCG.cginc>

Texture2D<float4> source;
RWTexture2D<float4> target;



// grid parameters
float worldToGrid;
float gridSize;
bool GridFlip;
RWStructuredBuffer<float> GridOneDensity;
RWStructuredBuffer<float> GridTwoDensity;

// light position
float3 lightPos;

// camera transform
float4x4 cameraToWorld;
float4x4 cameraInverseProjection;

// render parameters
float maxRange;
float minRange;
int steps;
int lightStepsPer100Distance;
float sigma_a;
float sigma_b;
float4 lightColor;

// helpers

struct Ray
{
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateRayFromCamera(float2 uv)
{
    float3 origin = mul(cameraToWorld, float4(0,0,0,1)).xyz;
    float3 _direction = mul(cameraInverseProjection, float4(uv, 0, 1)).xyz;
    float3 direction = normalize(mul(cameraToWorld, float4(_direction, 0)).xyz);
    return CreateRay(origin, direction);
}

float SampleGrid(float3 pos)
{
    return 0;
}

float SampleGridTrilinear(float3 pos)
{
    return 0;
}

// returns light attenuation
float RayMarchLight(float3 pos)
{
    float l = length(lightPos - pos);
    int steps = (int) round(lightStepsPer100Distance * l / 100);
    float stepSize = l / steps;
    return 0;
}

int CoordToIndex(int x, int y, int z)
{
    return gridSize * gridSize * x + gridSize * y + z;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    target[id.xy] = source[id.xy];
}
